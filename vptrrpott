import requests
import re
import json
import pygal
from pygal.style import Style
import io
import os
from urllib.parse import urlparse

def save_html_report(report, filename):
    """Save the HTML report to a file."""
    with io.open(filename, "w", encoding="utf-8") as file:
        file.write(report)

def get_severity_color(severity):
    """Return the color for a given severity level."""
    severity_colors = {
        "Critical": "maroon",
        "High": "red",
        "Medium": "orange",
        "Low": "yellow",
        "Info": "grey"
    }
    return severity_colors.get(severity, "transparent")

def strip_vulnerability_id(vulnerability_id):
    """Extract and clean the vulnerability ID."""
    if vulnerability_id is None or not isinstance(vulnerability_id, dict):
        return "N/A"
    vulnerability_id = vulnerability_id.get("vulnerability_id", "").strip("{'vulnerability_id': '").rstrip("'}")
    return vulnerability_id

def get_actual_image_url(finding_id, file_id, api_key):
    """Get the actual image URL from the Content-Disposition header of the file download endpoint."""
    try:
        headers = {
            "Authorization": f"Token {api_key}",
            "Content-Type": "application/json"
        }
        download_url = f"https://demo.defectdojo.org/api/v2/findings/{finding_id}/files/download/{file_id}/"
        
        # Make a HEAD request to get the Content-Disposition header
        response = requests.head(download_url, headers=headers, allow_redirects=True)
        
        if response.status_code == 200 and 'Content-Disposition' in response.headers:
            content_disposition = response.headers['Content-Disposition']
            # Extract filename from Content-Disposition (e.g., file_name=uploaded_files/ala7d-jsjjjs-ujnnn.png)
            match = re.search(r'file_name=([^\s]+)', content_disposition)
            if match:
                file_path = match.group(1)  # e.g., uploaded_files/ala7d-jsjjjs-ujnnn.png
                filename = os.path.basename(file_path)  # e.g., ala7d-jsjjjs-ujnnn.png
                # Construct the actual image URL
                actual_url = f"https://demo.defectdojo.org/media/uploaded_files/{filename}"
                return actual_url, filename
        print(f"Failed to get Content-Disposition for file_id {file_id} in finding {finding_id}. Status code: {response.status_code}")
        return None, None
    except Exception as e:
        print(f"Error getting actual image URL for file_id {file_id} in finding {finding_id}: {str(e)}")
        return None, None

def download_image(img_url, finding_id, api_key, local_base_path="media"):
    """Download an image, resolving blob URLs via the findings files API."""
    try:
        headers = {
            "Authorization": f"Token {api_key}",
            "Content-Type": "application/json"
        }
        
        # Check if the URL is a blob URL
        if img_url.startswith("blob:"):
            # Extract file_id from the blob URL or finding data (assuming file_id is part of the URL or finding)
            # For simplicity, assume we need to query the findings files API
            files_url = f"https://demo.defectdojo.org/api/v2/findings/{finding_id}/files/"
            response = requests.get(files_url, headers=headers)
            
            if response.status_code == 200:
                files_data = response.json()
                files = files_data.get("results", [])
                if files:
                    # Assume the first file is the one referenced (adjust if multiple files)
                    file_id = files[0].get("id")
                    actual_url, filename = get_actual_image_url(finding_id, file_id, api_key)
                    if not actual_url:
                        print(f"No actual URL found for blob URL {img_url}")
                        return img_url
                else:
                    print(f"No files found for finding {finding_id}")
                    return img_url
            else:
                print(f"Failed to fetch files for finding {finding_id}. Status code: {response.status_code}")
                return img_url
        else:
            actual_url, filename = img_url, os.path.basename(urlparse(img_url).path)
        
        # Download the image from the actual URL
        response = requests.get(actual_url, headers=headers, stream=True)
        
        if response.status_code == 200:
            # Ensure the filename has a valid image extension
            if not filename or not filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif')):
                filename = f"image_{hash(actual_url)}.png"
            
            # Construct the local path (e.g., media/uploaded_files/ala7d-jsjjjs-ujnnn.png)
            folder_structure = os.path.join(local_base_path, "uploaded_files")
            os.makedirs(folder_structure, exist_ok=True)
            local_path = os.path.join(folder_structure, filename)
            
            # Save the image
            with open(local_path, 'wb') as f:
                for chunk in response.iter_content(1024):
                    f.write(chunk)
            
            print(f"Successfully downloaded image to {local_path}")
            return local_path
        else:
            print(f"Failed to download image from {actual_url}. Status code: {response.status_code}")
            return img_url
    except Exception as e:
        print(f"Error downloading image from {img_url} (resolved to {actual_url}): {str(e)}")
        return img_url

def generate_html_report(finding_data, report_name, start_date, end_date, prepared_by, reviewed_by, approved_by, api_key):
    """Generate an HTML report with findings and embedded images."""
    # Sort findings by severity
    sorted_findings = sorted(finding_data, key=lambda x: ["Critical", "High", "Medium", "Low", "Info"].index(x["severity"]))
    
    # Count the occurrences of each severity
    severity_counts = {"Critical": 0, "High": 0, "Medium": 0, "Low": 0, "Info": 0}
    for finding in sorted_findings:
        severity = finding["severity"]
        severity_counts[severity] += 1
    
    # Generate the HTML report
    html_report = f"""
    <!DOCTYPE html>
    <html>
    <head>
      <title>DefectDojo Findings Report</title>
      <style>
        body {{
          border: 1px solid #ccc;
          padding: 10px;
          font-size: 16px;
        }}
        h1 {{
          font-size: 18px;
          font-weight: bold;
        }}
        .report-heading {{
          font-size: 34px;
          font-weight: bold;
        }}
        .finding-title {{
          background-color: rgba(32, 166, 216, 0.75);
          color: white;
          padding: 10px;
          margin-top: 20px;
        }}
        .severity-box {{
          display: inline-block;
          padding: 5px;
          margin-bottom: 10px;
          color: white;
        }}
        .severity-high {{
          background-color: red;
        }}
        .severity-medium {{
          background-color: orange;
        }}
        .severity-low {{
          background-color: yellow;
        }}
        .severity-info {{
          background-color: grey;
        }}
        .hardcoded-line {{
          border-top: 1px solid #000;
          margin-top: 1px;
          padding-top: 1px;
          border-width: 1px;
        }}
        .step-image {{
          border: 1px solid #ccc;
          padding: 5px;
          margin-bottom: 10px;
        }}
        .steps_to_reproduce {{
          list-style-type: none;
          padding-left: 0;
        }}
        table {{
          border-collapse: collapse;
          width: 100%;
        }}
        th, td {{
          padding: 8px;
          text-align: left;
          border-bottom: 1px solid #ddd;
        }}
        .Sub-Title {{
          font-size: 24px;
        }}
      </style>
    </head>
    <body>
    <div class="cover-page">
      <img src="logo">
      <h2 class="report-heading">{report_name}</h2>
      <h1>Application Security</h1>
      <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
      <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
      <div class="Sub-Title">
        <p><strong>Report Properties:</strong></p>
        <p><strong>VAPT Dates:</strong></p>
      </div>
      <table>
        <tr>
          <th>Start Date: </th><td>{start_date}</td>
        </tr>
        <tr>
          <th>End Date: </th><td>{end_date}</td> 
        </tr>      
        <tr>
          <th>Report Prepared by: </th><td>{prepared_by}</td>
        </tr>
        <tr>
          <th>Reviewed by: </th><td>{reviewed_by}</td>
        </tr>
        <tr>
          <th>Approved by: </th><td>{approved_by}</td>
        </tr>
      </table>
    </div>
    <br><br><br><br><br><br>
    """

    # Generate the pie chart
    custom_style = Style(value_font_size=4)
    pie_chart = pygal.Pie(width=400, height=200, print_values=True, style=custom_style, value_formatter=lambda x: f"({(x * 100 / sum(severity_counts.values())):.2f}%)")
    pie_chart.title = "Findings by Severity"
    for severity, count in severity_counts.items():
        pie_chart.add(f"{severity}, ({count})", count)
    
    chart_svg = pie_chart.render()
    chart_svg = chart_svg.replace(b'\n', b' ')
    chart_svg_str = chart_svg.decode("utf-8")
    chart_svg_str = chart_svg_str.replace("b' '", "")
    
    # Append the chart SVG to the HTML report
    html_report += f'<div>{chart_svg_str}</div>'
    
    # Initialize severity_findings dictionary
    severity_findings = {}
    severity_colors = {
        "Critical": {"background": "maroon", "font": "black"},
        "High": {"background": "red", "font": "black"},
        "Medium": {"background": "orange", "font": "black"},
        "Low": {"background": "yellow", "font": "black"},
        "Info": {"background": "grey", "font": "black"}
    }
    
    # Group findings by severity
    for finding in sorted_findings:
        severity = finding["severity"]
        if severity not in severity_findings:
            severity_findings[severity] = []
        severity_findings[severity].append(finding)

    # Index page with a list of all findings
    html_report += "<h2 id='top'>Findings Index</h2>"
    severity_order = ["Critical", "High", "Medium", "Low", "Info"]
    for severity in severity_order:
        findings = severity_findings.get(severity, [])
        if findings:
            color = severity_colors.get(severity, {})
            background_color = color.get("background", "white")
            font_color = color.get("font", "black")
            html_report += f"<h1 style='background-color: {background_color}; color: {font_color}'>{severity} Findings:</h1>"
            html_report += "<ul>"
            for i, finding in enumerate(findings, start=1):
                finding_title = finding["title"]
                html_report += f'<li><a href="#finding{i}">Finding {i}: {finding_title}</a></li>'
            html_report += "</ul>"
    
    html_report += "<br><br><br>"
    html_report += "<p><h2>Findings Details</h2></p>"
    
    for i, finding in enumerate(sorted_findings, start=1):
        finding_title = finding["title"]
        finding_id = finding.get("id", "unknown")
        vulnerability_id = finding["vulnerability_ids"][0] if finding["vulnerability_ids"] else "N/A"
        vulnerability_id = strip_vulnerability_id(vulnerability_id)
        description = finding["description"].replace("\r\n", "<br>") if finding["description"] else "N/A"
        cvssv3 = finding.get("cvssv3", "N/A")
        cvssv3_score = finding.get("cvssv3_score", "N/A")
        severity = finding["severity"]
        steps_to_reproduce = finding["steps_to_reproduce"].replace("\r\n", "<br>") if finding["steps_to_reproduce"] else "N/A"
        mitigation = finding["mitigation"].replace("\r\n", "<br>") if finding["mitigation"] else "N/A"
        impact = finding["impact"].replace("\r\n", "<br>") if finding["impact"] else "N/A"
        
        html_report += f"""
        <br><br><br>
        <div id="finding{i}" class="finding-border">
          <div class="finding-title">
            <h1 id="finding{i}">Finding {i}: {finding_title}</h1></div>
        </div>
        <p><strong>Jira ID:</strong> {vulnerability_id}</p>
        <hr class="hardcoded-line">
        <p><strong>Description:</strong> {description}</p>
        <hr class="hardcoded-line">
        <p><strong>CVSSv3:</strong> {cvssv3}</p>
        <hr class="hardcoded-line">
        <p><strong>CVSSv3 Score:</strong> {cvssv3_score}</p>
        <hr class="hardcoded-line">
        <div class="severity-box severity-{severity.lower()}" style="background-color: {get_severity_color(severity)};">
          <strong>Severity:</strong> {severity}
        </div>
        <hr class="hardcoded-line">
        <p><strong>Impact:</strong> {impact}</p>
        <hr class="hardcoded-line">
        <p><strong>Mitigation:</strong> {mitigation}</p>
        <hr class="hardcoded-line">
        <p><strong>Steps to Reproduce:</strong></p>
        <ul class="steps_to_reproduce">
        """
        
        # Parse steps_to_reproduce and handle images
        for step in steps_to_reproduce.split("<br>"):
            img_regex = r"!\[\]\((https?://[^\s]+)\)"
            img_urls = re.findall(img_regex, step)
            for img_url in img_urls:
                # Download the image and get the local path
                local_img_path = download_image(img_url, finding_id, api_key)
                # Replace the blob or original URL with the local path
                step = step.replace(f"![]({img_url})", f'<img class="step-image" src="{local_img_path}" style="max-width: 1000px; max-height: 800px;"><br>')
            
            html_report += f"<li>{step}</li>"
        
        html_report += "</ul><hr></div>"
    
    html_report += """
    <div class="cover-page-bottom"></div>
    </body>
    </html>
    """
    
    return html_report

# Prompt the user for inputs
test_ids = input("Enter the Test IDs (comma-separated): ").split(",")
report_name = input("Enter Report Name: ")
start_date = input("Enter Start Date: ")
end_date = input("End Date: ")
prepared_by = input("Enter name of prepared by person: ")
reviewed_by = input("Enter name of reviewed by person: ")
approved_by = input("Enter name of approved by person: ")

# DefectDojo API endpoint
api_url = "https://demo.defectdojo.org/api/v2/tests/{}/generate_report/"

# Set your authentication API key
api_key = "abc"  # Replace with your actual API key

# Set the headers
headers = {
    "Authorization": f"Token {api_key}",
    "Content-Type": "application/json"
}

finding_data = []

for test_id in test_ids:
    # Make a POST request to generate the report for each test ID
    response = requests.post(api_url.format(test_id.strip()), headers=headers)
    
    # Check if the request was successful
    if response.status_code == 200:
        try:
            report_data = response.json()
            findings = report_data.get("findings", [])
            
            if findings:
                for finding in findings:
                    finding_data.append(finding)
            else:
                print(f"No findings found for Test ID: {test_id.strip()}")
        except json.JSONDecodeError:
            print(f"Error decoding JSON response for Test ID: {test_id.strip()}")
    else:
        print(f"Error fetching findings for Test ID: {test_id.strip()}. Status code: {response.status_code}")
    
    print("\n---\n")

# Generate the HTML report
html_report = generate_html_report(finding_data, report_name, start_date, end_date, prepared_by, reviewed_by, approved_by, api_key)

# Save the HTML report
filename = "report.html"
save_html_report(html_report, filename)

print(f"HTML report saved as: {filename}")