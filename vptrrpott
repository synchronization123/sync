# report_generator.pyw
import sys
import requests
import re
import json
import pygal
from pygal.style import Style
import io
import pdfkit
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QLabel, QLineEdit, QComboBox, QCheckBox, QPushButton, QScrollArea,
                             QProgressBar, QMessageBox, QGridLayout)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5.QtGui import QFont, QPalette, QColor

def save_html_report(report, filename):
    with io.open(filename, "w", encoding="utf-8") as file:
        file.write(report)
        
def get_severity_color(severity):
    if severity == "Critical":
        return "#800000"  # Maroon
    if severity == "High":
        return "#ff0000"  # Red
    elif severity == "Medium":
        return "#ffa500"  # Orange
    elif severity == "Low":
        return "#ffff00"  # Yellow
    elif severity == "Info":
        return "#808080"  # Grey
    else:
        return "#ffffff"  # White

def strip_vulnerability_id(vulnerability_id):
    if vulnerability_id is None or not isinstance(vulnerability_id, dict):
        return "N/A"    
    vulnerability_id = vulnerability_id.get("vulnerability_id", "").strip("{'vulnerability_id': '").rstrip("'}")
    return vulnerability_id

def generate_html_report(finding_data, report_name, start_date, end_date, prepared_by, reviewed_by, approved_by):    
    sorted_findings = sorted(finding_data, key=lambda x: ["Critical", "High", "Medium", "Low", "Info"].index(x["severity"])) if finding_data else []
    
    html_report = f"""
    <!DOCTYPE html>
    <html>
    <head>
      <title>DefectDojo Findings Report</title>
      <style>
        @page {{
          size: A4;
          margin: 20mm;
        }}
        body {{
          font-family: 'Aptos', Arial, sans-serif;
          font-size: 14.67px;
          line-height: 1.6;
          margin: 0;
          padding: 0;
          background-color: #f9f9f9;
          color: #333333;
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
        }}
        .container {{
          max-width: 1000px;
          margin: 0 auto;
          background-color: #ffffff;
          padding: 30px;
          border-radius: 8px;
          box-shadow: 0 2px 10px #00000033;
          page-break-inside: avoid;
        }}
        .cover-page {{
          position: relative;
          padding: 20px;
          border-radius: 8px;
          background-color: #f4faff;
          margin-bottom: 30px;
          page-break-inside: avoid;
        }}
        .logo-card {{
          display: inline-block;
          background-color: #ffffff;
          padding: 10px;
          border-radius: 4px;
          box-shadow: 0 1px 5px #00000033;
          margin-bottom: 20px;
        }}
        .logo {{
          width: 80px;
          height: auto;
        }}
        h1, h2, h3 {{
          font-family: 'Aptos Display', Arial, sans-serif;
          font-size: 18.67px;
          color: #1a3c5e;
        }}
        .report-heading {{
          font-size: 28px;
          font-weight: bold;
          text-align: center;
          margin-bottom: 20px;
          color: #20a6d8;
        }}
        .finding-title {{
          background-color: #20a6d8;
          color: #ffffff;
          padding: 12px;
          border-radius: 5px;
          margin: 0;
        }}
        .severity-box {{
          display: inline-block;
          padding: 8px 12px;
          margin-bottom: 15px;
          color: #ffffff;
          border-radius: 4px;
          font-weight: bold;
        }}
        .severity-critical {{
          background-color: #800000;
          color: #ffffff;
        }}
        .severity-high {{
          background-color: #ff0000;
          color: #ffffff;
        }}
        .severity-medium {{
          background-color: #ffa500;
          color: #ffffff;
        }}
        .severity-low {{
          background-color: #ffff00;
          color: #333333;
        }}
        .severity-info {{
          background-color: #808080;
          color: #ffffff;
        }}
        .hardcoded-line {{
          border-top: 1px solid #dddddd;
          margin: 15px 0;
        }}
        .step-image {{
          border: 1px solid #cccccc;
          padding: 5px;
          margin-bottom: 15px;
          max-width: 100%;
          border-radius: 4px;
        }}
        .steps_to_reproduce {{
          list-style-type: none;
          padding-left: 0;
        }}
        .steps_to_reproduce li {{
          margin-bottom: 10px;
          page-break-inside: avoid;
        }}
        table {{
          border-collapse: collapse;
          width: 100%;
          margin: 20px 0;
          background-color: #ffffff;
          border: 1px solid #dddddd;
          border-radius: 4px;
          page-break-inside: avoid;
        }}
        th, td {{
          padding: 12px;
          text-align: left;
          border-bottom: 1px solid #dddddd;
        }}
        th {{
          background-color: #f4f4f4;
          font-weight: bold;
          color: #1a3c5e;
        }}
        .Sub-Title {{
          font-size: 22px;
          margin-bottom: 15px;
          color: #20a6d8;
        }}
        .chart-container {{
          text-align: center;
          margin: 30px 0;
          padding: 20px;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 10px #00000033;
          page-break-before: always;
          page-break-inside: avoid;
        }}
        .no-findings {{
          text-align: center;
          color: #666666;
          font-style: italic;
          page-break-inside: avoid;
        }}
        .finding-border {{
          padding: 15px;
          margin-bottom: 20px;
          border-radius: 8px;
          background-color: #fafafa;
          box-shadow: 0 1px 5px #00000033;
          page-break-inside: avoid;
        }}
        .finding-border:first-of-type {{
          margin-top: 0;
          page-break-before: avoid;
        }}
        .finding-details h2 {{
          margin-bottom: 0;
          page-break-after: avoid;
        }}
        .finding-details {{
          page-break-inside: avoid;
          margin-top: 0;
        }}
        p {{
          page-break-inside: avoid;
          margin: 10px 0;
        }}
        a {{
          color: #20a6d8;
          text-decoration: none;
        }}
      </style>
    </head>
    <body>
    <div class="container">
      <div class="cover-page">
        <div class="logo-card">
          <img src="logo" class="logo" alt="Company Logo">
        </div>
        <h2 class="report-heading">{report_name}</h2>
        <h1 style="text-align: center;">Application Security</h1>
        <div class="Sub-Title">Report Properties</div>
        <table>
          <tr>
            <th>Start Date:</th><td>{start_date}</td>
          </tr>
          <tr>
            <th>End Date:</th><td>{end_date}</td> 
          </tr>      
          <tr>
            <th>Prepared by:</th><td>{prepared_by}</td>
          </tr>
          <tr>
            <th>Reviewed by:</th><td>{reviewed_by}</td>
          </tr>
          <tr>
            <th>Approved by:</th><td>{approved_by}</td>
          </tr>
        </table>
      </div>
    """

    severity_counts = {"Critical": 0, "High": 0, "Medium": 0, "Low": 0, "Info": 0}
    for finding in sorted_findings:
        severity = finding["severity"]
        severity_counts[severity] += 1
    
    custom_style = Style(
        value_font_size=4,
        colors=('#800000', '#ff0000', '#ffa500', '#ffff00', '#808080'),
        background='#ffffff',
        plot_background='#ffffff'
    )
    pie_chart = pygal.Pie(
        width=400,
        height=200,
        print_values=True,
        style=custom_style,
        value_formatter=lambda x: f"({(x * 100 / sum(severity_counts.values())):.2f}%)" if sum(severity_counts.values()) > 0 else "(0%)"
    )
    pie_chart.title = "Findings by Severity"
    for severity, count in severity_counts.items():
        pie_chart.add(f"{severity}, ({count})", count)

    chart_svg = pie_chart.render()
    chart_svg = chart_svg.replace(b'\n', b' ')
    chart_svg_str = chart_svg.decode("utf-8")
    chart_svg_str = chart_svg_str.replace("b' '", "")
    
    html_report += f'<div class="chart-container">{chart_svg_str}</div>'
        
    severity_findings = {}
    severity_colors = {
        "Critical": {"background": "#800000", "font": "#ffffff"},
        "High": {"background": "#ff0000", "font": "#ffffff"},
        "Medium": {"background": "#ffa500", "font": "#ffffff"},
        "Low": {"background": "#ffff00", "font": "#333333"},
        "Info": {"background": "#808080", "font": "#ffffff"}
    }
    
    for finding in sorted_findings:
        severity = finding["severity"]
        if severity not in severity_findings:
            severity_findings[severity] = []
        severity_findings[severity].append(finding)

    html_report += "<h2 id='top'>Findings Index</h2>"
    severity_order = ["Critical", "High", "Medium", "Low", "Info"]
    for severity in severity_order:
        findings = severity_findings.get(severity, [])
        if findings:
            color = severity_colors.get(severity, {})
            background_color = color.get("background", "#ffffff")
            font_color = color.get("font", "#333333")
            html_report += f"<h1 style='background-color: {background_color}; color: {font_color}; padding: 10px; border-radius: 4px; page-break-inside: avoid;'>{severity} Findings:</h1>"
            html_report += "<ul style='page-break-inside: avoid;'>"
            for i, finding in enumerate(findings, start=1):
                finding_title = finding["title"]
                html_report += f'<li><a href="#finding{i}" style="color: #20a6d8; text-decoration: none;">Finding {i}: {finding_title}</a></li>'
            html_report += "</ul>"
    
    html_report += "<div class='finding-details'><h2>Findings Details</h2>"
    
    if not sorted_findings:
        html_report += "<p class='no-findings'>No observation found</p>"
    else:
        for i, finding in enumerate(sorted_findings, start=1):
            finding_title = finding["title"]
            vulnerability_id = finding["vulnerability_ids"][0] if finding["vulnerability_ids"] else "N/A"
            vulnerability_id = strip_vulnerability_id(vulnerability_id)
            description = finding["description"].replace("\r\n", "<br>") if finding["description"] else "N/A"
            cvssv3 = finding["cvssv3"] if finding["cvssv3"] else "N/A"
            cvssv3_score = finding["cvssv3_score"] if finding["cvssv3_score"] else "N/A"
            severity = finding["severity"]
            steps_to_reproduce = finding["steps_to_reproduce"] if finding["steps_to_reproduce"] else "N/A"
            if isinstance(steps_to_reproduce, str):
                steps_to_reproduce = steps_to_reproduce.replace("\r\n", "<br>")
            mitigation = finding["mitigation"].replace("\r\n", "<br>") if finding["mitigation"] else "N/A"
            impact = finding["impact"].replace("\r\n", "<br>") if finding["impact"] else "N/A"
            
            html_report += f"""
            <div id="finding{i}" class="finding-border">
              <h1 class="finding-title" id="finding{i}">Finding {i}: {finding_title}</h1>
              <p><strong>Jira ID:</strong> {vulnerability_id}</p>
              <hr class="hardcoded-line">
              <p><strong>Description:</strong> {description}</p>
              <hr class="hardcoded-line">
              <p><strong>CVSSv3:</strong> {cvssv3}</p>
              <hr class="hardcoded-line">
              <p><strong>CVSSv3 Score:</strong> {cvssv3_score}</p>
              <hr class="hardcoded-line">
              <div class="severity-box severity-{severity.lower()}" style="background-color: {get_severity_color(severity)};">
                <strong>Severity:</strong> {severity}
              </div>
              <hr class="hardcoded-line">
              <p><strong>Impact:</strong> {impact}</p>
              <hr class="hardcoded-line">
              <p><strong>Mitigation:</strong> {mitigation}</p>
              <hr class="hardcoded-line">
              <p><strong>Steps to Reproduce:</strong></p>
              <ul class="steps_to_reproduce">
            """

            if isinstance(steps_to_reproduce, str):
                for step in steps_to_reproduce.split("<br>"):
                    if step.strip():
                        img_regex = r"!\[\]\((https?://[^\s]+)\)"
                        img_urls = re.findall(img_regex, step)
                        for img_url in img_urls:
                            step = step.replace(f"![]({img_url})", f'<img class="step-image" src="{img_url}" style="max-width: 1000px; max-height: 800px;"><br>')
                        html_report += f"<li>{step}</li>"
            else:
                html_report += f"<li>{steps_to_reproduce}</li>"

            html_report += "</ul><hr></div>"
    
    html_report += """
    </div>
    </div>
    </body>
    </html>
    """

    return html_report

class FetchEngagementsThread(QThread):
    engagements_fetched = pyqtSignal(list)
    error_occurred = pyqtSignal(str)

    def __init__(self, api_url, headers):
        super().__init__()
        self.api_url = api_url
        self.headers = headers

    def run(self):
        try:
            response = requests.get(self.api_url, headers=self.headers)
            if response.status_code == 200:
                engagements = response.json().get("results", [])
                self.engagements_fetched.emit(engagements)
            else:
                self.error_occurred.emit(f"Error fetching engagements: Status code {response.status_code}")
        except Exception as e:
            self.error_occurred.emit(f"Error fetching engagements: {str(e)}")

class FetchTestsThread(QThread):
    tests_fetched = pyqtSignal(list)
    error_occurred = pyqtSignal(str)

    def __init__(self, api_url, headers, engagement_id):
        super().__init__()
        self.api_url = api_url
        self.headers = headers
        self.engagement_id = engagement_id

    def run(self):
        try:
            response = requests.get(self.api_url.format(self.engagement_id), headers=self.headers)
            if response.status_code == 200:
                tests = response.json().get("results", [])
                self.tests_fetched.emit(tests)
            else:
                self.error_occurred.emit(f"Error fetching tests: Status code {response.status_code}")
        except Exception as e:
            self.error_occurred.emit(f"Error fetching tests: {str(e)}")

class GenerateReportThread(QThread):
    report_generated = pyqtSignal()
    error_occurred = pyqtSignal(str)

    def __init__(self, test_ids, report_name, start_date, end_date, prepared_by, reviewed_by, approved_by, api_url, headers):
        super().__init__()
        self.test_ids = test_ids
        self.report_name = report_name
        self.start_date = start_date
        self.end_date = end_date
        self.prepared_by = prepared_by
        self.reviewed_by = reviewed_by
        self.approved_by = approved_by
        self.api_url = api_url
        self.headers = headers

    def run(self):
        try:
            finding_data = []
            for test_id in self.test_ids:
                response = requests.post(self.api_url.format(test_id), headers=self.headers)
                if response.status_code == 200:
                    report_data = response.json()
                    findings = report_data.get("findings", [])
                    if findings:
                        finding_data.extend(findings)
                else:
                    self.error_occurred.emit(f"Error fetching findings for Test ID {test_id}: Status code {response.status_code}")
                    return

            html_report = generate_html_report(finding_data, self.report_name, self.start_date, self.end_date,
                                              self.prepared_by, self.reviewed_by, self.approved_by)
            filename = "report.html"
            save_html_report(html_report, filename)

            try:
                import pdfkit
                options = {
                    'page-size': 'A4',
                    'margin-top': '20mm',
                    'margin-right': '20mm',
                    'margin-bottom': '20mm',
                    'margin-left': '20mm',
                    'encoding': "UTF-8",
                    'enable-local-file-access': None,
                    'print-media-type': None,
                    'no-outline': None
                }
                pdfkit.from_file(filename, "report.pdf", options=options)
            except ImportError:
                self.error_occurred.emit("pdfkit not installed. Install it using 'pip install pdfkit' and ensure wkhtmltopdf is installed.")
                return
            except Exception as e:
                self.error_occurred.emit(f"Error generating PDF: {str(e)}")
                return

            self.report_generated.emit()
        except Exception as e:
            self.error_occurred.emit(f"Error generating report: {str(e)}")

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("DefectDojo Report Generator")
        self.setFixedSize(800, 600)

        # API settings
        self.api_key = "abc"
        self.headers = {
            "Authorization": f"Token {self.api_key}",
            "Content-Type": "application/json"
        }
        self.engagements_url = "https://demo.defectdojo.org/api/v2/engagements/"
        self.tests_url = "https://demo.defectdojo.org/api/v2/tests/?engagement_id={}"
        self.report_url = "https://demo.defectdojo.org/api/v2/tests/{}/generate_report/"

        # GUI setup
        self.init_ui()
        self.fetch_engagements()

    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(20, 20, 20, 20)

        # Modern styling
        self.setStyleSheet("""
            QWidget {
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 14px;
            }
            QLineEdit, QComboBox {
                padding: 8px;
                border: 1px solid #cccccc;
                border-radius: 4px;
                background-color: #ffffff;
            }
            QPushButton {
                padding: 10px;
                border: none;
                border-radius: 4px;
                background-color: #20a6d8;
                color: white;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1a8cc0;
            }
            QLabel {
                color: #333333;
            }
            QCheckBox {
                margin: 5px 0;
            }
            QScrollArea {
                border: 1px solid #cccccc;
                border-radius: 4px;
                background-color: #ffffff;
            }
        """)

        # Engagement selection
        engagement_layout = QHBoxLayout()
        engagement_label = QLabel("Select Engagement:")
        self.engagement_combo = QComboBox()
        self.engagement_combo.setEditable(True)
        self.engagement_combo.setMinimumWidth(300)
        self.engagement_combo.setCompleter(self.engagement_combo.completer())
        self.engagement_combo.currentIndexChanged.connect(self.on_engagement_selected)
        engagement_layout.addWidget(engagement_label)
        engagement_layout.addWidget(self.engagement_combo)
        main_layout.addLayout(engagement_layout)

        # Test selection
        test_label = QLabel("Select Tests:")
        main_layout.addWidget(test_label)
        self.test_scroll = QScrollArea()
        self.test_scroll.setWidgetResizable(True)
        self.test_container = QWidget()
        self.test_layout = QVBoxLayout(self.test_container)
        self.test_scroll.setWidget(self.test_container)
        self.test_scroll.setMinimumHeight(150)
        main_layout.addWidget(self.test_scroll)

        # Report properties
        properties_widget = QWidget()
        properties_layout = QGridLayout(properties_widget)
        properties_layout.setSpacing(10)

        self.report_name_input = QLineEdit()
        self.start_date_input = QLineEdit()
        self.end_date_input = QLineEdit()
        self.prepared_by_input = QLineEdit()
        self.reviewed_by_input = QLineEdit()
        self.approved_by_input = QLineEdit()

        properties_layout.addWidget(QLabel("Report Name:"), 0, 0)
        properties_layout.addWidget(self.report_name_input, 0, 1)
        properties_layout.addWidget(QLabel("Start Date:"), 1, 0)
        properties_layout.addWidget(self.start_date_input, 1, 1)
        properties_layout.addWidget(QLabel("End Date:"), 2, 0)
        properties_layout.addWidget(self.end_date_input, 2, 1)
        properties_layout.addWidget(QLabel("Prepared By:"), 3, 0)
        properties_layout.addWidget(self.prepared_by_input, 3, 1)
        properties_layout.addWidget(QLabel("Reviewed By:"), 4, 0)
        properties_layout.addWidget(self.reviewed_by_input, 4, 1)
        properties_layout.addWidget(QLabel("Approved By:"), 5, 0)
        properties_layout.addWidget(self.approved_by_input, 5, 1)

        main_layout.addWidget(properties_widget)

        # Generate report button
        self.generate_button = QPushButton("Generate Report")
        self.generate_button.clicked.connect(self.generate_report)
        main_layout.addWidget(self.generate_button)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        main_layout.addWidget(self.progress_bar)

        # Status label
        self.status_label = QLabel("")
        self.status_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.status_label)

        main_layout.addStretch()

    def fetch_engagements(self):
        self.status_label.setText("Fetching engagements...")
        self.progress_bar.setVisible(True)
        self.engagement_thread = FetchEngagementsThread(self.engagements_url, self.headers)
        self.engagement_thread.engagements_fetched.connect(self.populate_engagements)
        self.engagement_thread.error_occurred.connect(self.show_error)
        self.engagement_thread.start()

    def populate_engagements(self, engagements):
        self.engagement_combo.clear()
        self.engagements = engagements
        for engagement in engagements:
            self.engagement_combo.addItem(engagement["name"], engagement["id"])
        self.progress_bar.setVisible(False)
        self.status_label.setText("Engagements loaded")

    def on_engagement_selected(self, index):
        if index == -1:
            return
        engagement_id = self.engagement_combo.itemData(index)
        self.status_label.setText("Fetching tests...")
        self.progress_bar.setVisible(True)
        self.clear_test_checkboxes()
        self.test_thread = FetchTestsThread(self.tests_url, self.headers, engagement_id)
        self.test_thread.tests_fetched.connect(self.populate_tests)
        self.test_thread.error_occurred.connect(self.show_error)
        self.test_thread.start()

    def clear_test_checkboxes(self):
        while self.test_layout.count():
            item = self.test_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

    def populate_tests(self, tests):
        self.tests = tests
        for test in tests:
            checkbox = QCheckBox(test["title"])
            checkbox.setProperty("test_id", test["id"])
            self.test_layout.addWidget(checkbox)
        self.progress_bar.setVisible(False)
        self.status_label.setText("Tests loaded")

    def generate_report(self):
        selected_tests = [checkbox.property("test_id") for checkbox in self.test_container.findChildren(QCheckBox) if checkbox.isChecked()]
        if not selected_tests:
            QMessageBox.warning(self, "Warning", "Please select at least one test.")
            return

        report_name = self.report_name_input.text().strip()
        start_date = self.start_date_input.text().strip()
        end_date = self.end_date_input.text().strip()
        prepared_by = self.prepared_by_input.text().strip()
        reviewed_by = self.reviewed_by_input.text().strip()
        approved_by = self.approved_by_input.text().strip()

        if not all([report_name, start_date, end_date, prepared_by, reviewed_by, approved_by]):
            QMessageBox.warning(self, "Warning", "Please fill in all report properties.")
            return

        self.status_label.setText("Generating report...")
        self.progress_bar.setVisible(True)
        self.generate_button.setEnabled(False)

        self.report_thread = GenerateReportThread(selected_tests, report_name, start_date, end_date,
                                                 prepared_by, reviewed_by, approved_by, self.report_url, self.headers)
        self.report_thread.report_generated.connect(self.on_report_generated)
        self.report_thread.error_occurred.connect(self.show_error)
        self.report_thread.start()

    def on_report_generated(self):
        self.progress_bar.setVisible(False)
        self.generate_button.setEnabled(True)
        self.status_label.setText("Report generated successfully as report.html and report.pdf")
        QMessageBox.information(self, "Success", "Report generated successfully!")

    def show_error(self, error_message):
        self.progress_bar.setVisible(False)
        self.generate_button.setEnabled(True)
        self.status_label.setText("Error occurred")
        QMessageBox.critical(self, "Error", error_message)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())