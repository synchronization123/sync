import requests
import base64
import pandas as pd
from datetime import datetime, timedelta
from openpyxl import load_workbook, Workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment, Font, Border, Side, PatternFill
import os

# Step 1: Set up SonarQube API token and headers
sonartoken = "gdjdjdjdjdjrjjrjd"
auth_string = f"{sonartoken}:"
auth_encoded = base64.b64encode(auth_string.encode()).decode()
headers = {
    "Authorization": f"Basic {auth_encoded}",
    "Accept": "application/json",
    "Content-Type": "application/json"
}

# Step 2: Fetch projects and save to Projects.xlsx
project_url = "https://sonar.crm.com/api/components/search?qualifiers=TRK&ps=500"
response = requests.get(project_url, headers=headers)
projects_data = response.json()

# Extract project details
projects_list = []
for component in projects_data.get("components", []):
    projects_list.append({
        "key": component["key"],
        "name": component["name"],
        "project": component["name"]
    })

# Save to Projects.xlsx
projects_df = pd.DataFrame(projects_list)
projects_df.to_excel("Projects.xlsx", index=False)

# Step 3: Fetch vulnerabilities for each project with pagination and save to Vulnerabilities.xlsx
vulnerabilities_list = []
for key in projects_df["key"]:
    page = 1
    while True:
        vuln_url = f"https://sonar.crm.com/api/issues/search?componentKeys={key}&types=VULNERABILITY&resolved=false&statuses=OPEN&p={page}"
        response = requests.get(vuln_url, headers=headers)
        vuln_data = response.json()

        # Extract issues from the current page
        issues = vuln_data.get("issues", [])
        for issue in issues:
            vulnerabilities_list.append({
                "key": issue["key"],
                "severity": issue.get("severity", ""),
                "component": issue.get("component", ""),
                "project": issue.get("project", ""),
                "line": issue.get("line", ""),
                "status": issue.get("status", ""),
                "message": issue.get("message", "")
            })

        # Check pagination metadata to determine if there are more pages
        total = vuln_data.get("total", 0)
        page_size = vuln_data.get("ps", 100)  # Default page size is typically 100
        current_page = vuln_data.get("p", 1)

        # If the current page has fewer issues than the page size, or we've fetched all issues, break
        if len(issues) < page_size or (current_page * page_size) >= total:
            break

        page += 1

# Save to Vulnerabilities.xlsx
vulnerabilities_df = pd.DataFrame(vulnerabilities_list)
vulnerabilities_df.to_excel("Vulnerabilities.xlsx", index=False)

# Step 4: Fetch hotspots for each project with pagination and save to Hotspots.xlsx
hotspots_list = []
for key in projects_df["key"]:
    page = 1
    while True:
        hotspot_url = f"https://sonar.crm.com/api/hotspots/search?projectKey={key}&status=TO_REVIEW&p={page}"
        response = requests.get(hotspot_url, headers=headers)
        hotspot_data = response.json()

        # Extract hotspots from the current page
        hotspots = hotspot_data.get("hotspots", [])
        for hotspot in hotspots:
            hotspots_list.append({
                "key": hotspot["key"],
                "component": hotspot.get("component", ""),
                "project": hotspot.get("project", ""),
                "securityCategory": hotspot.get("securityCategory", ""),
                "vulnerabilityProbability": hotspot.get("vulnerabilityProbability", ""),
                "status": hotspot.get("status", ""),
                "line": hotspot.get("line", ""),
                "message": hotspot.get("message", "")
            })

        # Check pagination metadata to determine if there are more pages
        paging = hotspot_data.get("paging", {})
        total = paging.get("total", 0)
        page_size = paging.get("pageSize", 100)  # Default page size is typically 100
        current_page = paging.get("pageIndex", 1)

        # If the current page has fewer hotspots than the page size, or we've fetched all hotspots, break
        if len(hotspots) < page_size or (current_page * page_size) >= total:
            break

        page += 1

# Save to Hotspots.xlsx
hotspots_df = pd.DataFrame(hotspots_list)
hotspots_df.to_excel("Hotspots.xlsx", index=False)

# Step 5: Prepare data for Final.xlsx
# Get unique project keys from both Vulnerabilities and Hotspots
unique_projects = set(vulnerabilities_df["project"]).union(set(hotspots_df["project"]))

# Dynamically get the current date
current_date = datetime.now()
current_date_str = current_date.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")

# Define categories for vulnerabilities and hotspots separately
vuln_categories = ["BLOCKER", "CRITICAL", "MAJOR", "MINOR", "INFO"]
hotspot_categories = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "OTHER"]

# Number of columns per date for vulnerabilities, hotspots, and total
vuln_cols_per_date = len(vuln_categories)  # 5
hotspot_cols_per_date = len(hotspot_categories)  # 5
total_cols_per_date = vuln_cols_per_date + hotspot_cols_per_date + 1  # 11 (includes Total)

# Check if Final.xlsx exists to determine the dates to include
if os.path.exists("Final.xlsx"):
    # Use openpyxl to read the dates from row 1
    wb = load_workbook("Final.xlsx")
    ws = wb.active
    existing_dates = set()
    for col in range(2, ws.max_column + 1, total_cols_per_date):  # Start from column B, step by 11 columns
        date_cell = ws.cell(row=1, column=col).value
        if date_cell:
            # Convert datetime objects to strings in the same format
            if isinstance(date_cell, datetime):
                date_str = date_cell.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")
                existing_dates.add(date_str)
            else:
                existing_dates.add(str(date_cell))
    wb.close()

    dates = list(existing_dates) + [current_date_str]
else:
    # If Final.xlsx doesn't exist, use only the current date
    dates = [current_date_str]
    existing_projects = set()

# Remove duplicates and sort dates (all elements are now strings)
dates = sorted(list(set(dates)))

# Load existing projects
if os.path.exists("Final.xlsx"):
    # Load the data with pandas, using row 3 (index 2) as the header
    existing_df = pd.read_excel("Final.xlsx", header=2)
    
    # Rename the first column to "project"
    existing_df.columns = ["project"] + list(existing_df.columns[1:])
    
    # Extract existing projects, excluding "Total" row
    existing_projects = set(existing_df["project"].values)
    if "Total" in existing_projects:
        existing_projects.remove("Total")
else:
    existing_projects = set()

# Initialize the pivot table structure (only for the current date)
pivot_data = []
all_projects = unique_projects.union(existing_projects)

for project in all_projects:
    row = {"project": project}
    
    # Only calculate counts for the current date
    # Filter vulnerabilities and hotspots for the project
    vuln_filtered = vulnerabilities_df[vulnerabilities_df["project"] == project]
    hotspot_filtered = hotspots_df[hotspots_df["project"] == project]

    # Add vulnerability counts
    for category in vuln_categories:
        count = len(vuln_filtered[vuln_filtered["severity"] == category])
        row[f"{current_date_str}_VULNERABILITY_{category}"] = count if count > 0 else None

    # Add hotspot counts
    for category in hotspot_categories:
        count = len(hotspot_filtered[hotspot_filtered["vulnerabilityProbability"] == category])
        row[f"{current_date_str}_HOTSPOT_{category}"] = count if count > 0 else None

    # Add total for this date
    total = 0
    for category in vuln_categories:
        count = row.get(f"{current_date_str}_VULNERABILITY_{category}", 0)
        total += count if count is not None else 0
    for category in hotspot_categories:
        count = row.get(f"{current_date_str}_HOTSPOT_{category}", 0)
        total += count if count is not None else 0
    row[f"{current_date_str}_Total"] = total if total > 0 else None

    pivot_data.append(row)

# Create DataFrame for the pivot table (only current date columns)
pivot_df = pd.DataFrame(pivot_data)

# If Final.xlsx exists, merge with existing data
if os.path.exists("Final.xlsx"):
    # Load existing data
    existing_df = pd.read_excel("Final.xlsx", header=2)
    
    # Rename the first column to "project"
    existing_df.columns = ["project"] + list(existing_df.columns[1:])
    
    # Remove the Total row if it exists
    existing_df = existing_df[existing_df["project"] != "Total"]
    
    # Merge with new data (append current date columns, preserve existing columns)
    combined_df = existing_df.set_index("project").combine_first(pivot_df.set_index("project")).reset_index()
    # Ensure we're working with a fresh copy to avoid SettingWithCopyWarning
    pivot_df = combined_df.copy()
else:
    # If Final.xlsx doesn't exist, pivot_df is the final DataFrame
    pass

# Reorder columns
columns_order = ["project"]
for date in dates:
    columns_order.extend([f"{date}_VULNERABILITY_{category}" for category in vuln_categories])
    columns_order.extend([f"{date}_HOTSPOT_{category}" for category in hotspot_categories])
    columns_order.append(f"{date}_Total")
pivot_df = pivot_df[columns_order]

# Add Total row at the bottom
total_row = {"project": "Total"}
for col in pivot_df.columns[1:]:  # Skip the project column
    total_row[col] = pivot_df[col].sum()
total_df = pd.DataFrame([total_row])
pivot_df = pd.concat([pivot_df, total_df], ignore_index=True)

# Save to Final.xlsx with two extra rows at the top for date and section headers
with pd.ExcelWriter("Final.xlsx", engine="openpyxl") as writer:
    pivot_df.to_excel(writer, index=False, startrow=2)

# Step 6: Use openpyxl to format the Excel file
wb = load_workbook("Final.xlsx")
ws = wb.active

# Define border styles
thin_border = Border(
    left=Side(style="thin"),
    right=Side(style="thin"),
    top=Side(style="thin"),
    bottom=Side(style="thin")
)
bold_border = Border(
    left=Side(style="medium"),
    right=Side(style="medium"),
    top=Side(style="medium"),
    bottom=Side(style="medium")
)

# Define gray fill for date cells
gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")

# Merge cells for each date in row 1 and apply formatting
for i, date in enumerate(dates):
    start_col = 2 + i * total_cols_per_date  # Start after 'project' column
    end_col = start_col + total_cols_per_date - 1  # Includes Total column
    start_col_letter = get_column_letter(start_col)
    end_col_letter = get_column_letter(end_col)
    ws.merge_cells(f"{start_col_letter}1:{end_col_letter}1")
    date_cell = ws[f"{start_col_letter}1"]
    date_cell.value = date
    date_cell.alignment = Alignment(horizontal="center", vertical="center")
    date_cell.font = Font(bold=True)
    date_cell.fill = gray_fill  # Apply gray background
    # Apply border to merged date cell
    for col in range(start_col, end_col + 1):
        ws.cell(row=1, column=col).border = thin_border

# Merge cells for "VULNERABILITY" and "HOTSPOT" in row 2 and apply formatting
for i, date in enumerate(dates):
    # VULNERABILITY section
    vuln_start_col = 2 + i * total_cols_per_date
    vuln_end_col = vuln_start_col + vuln_cols_per_date - 1
    vuln_start_col_letter = get_column_letter(vuln_start_col)
    vuln_end_col_letter = get_column_letter(vuln_end_col)
    ws.merge_cells(f"{vuln_start_col_letter}2:{vuln_end_col_letter}2")
    vuln_cell = ws[f"{vuln_start_col_letter}2"]
    vuln_cell.value = "VULNERABILITY"
    vuln_cell.alignment = Alignment(horizontal="center", vertical="center")
    vuln_cell.font = Font(bold=True)
    # Apply border to merged VULNERABILITY cell
    for col in range(vuln_start_col, vuln_end_col + 1):
        ws.cell(row=2, column=col).border = thin_border

    # HOTSPOT section
    hotspot_start_col = vuln_end_col + 1
    hotspot_end_col = hotspot_start_col + hotspot_cols_per_date - 1
    hotspot_start_col_letter = get_column_letter(hotspot_start_col)
    hotspot_end_col_letter = get_column_letter(hotspot_end_col)
    ws.merge_cells(f"{hotspot_start_col_letter}2:{hotspot_end_col_letter}2")
    hotspot_cell = ws[f"{hotspot_start_col_letter}2"]
    hotspot_cell.value = "HOTSPOT"
    hotspot_cell.alignment = Alignment(horizontal="center", vertical="center")
    hotspot_cell.font = Font(bold=True)
    # Apply border to merged HOTSPOT cell
    for col in range(hotspot_start_col, hotspot_end_col + 1):
        ws.cell(row=2, column=col).border = thin_border

# Update the headers in row 3 to show only the category names and apply borders
for col_idx, col_name in enumerate(pivot_df.columns, start=1):
    cell = ws.cell(row=3, column=col_idx)
    if col_name != "project":
        if col_name.endswith("_Total"):
            cell.value = "Total"
        else:
            category = col_name.split("_")[-1]  # Extract the category (e.g., BLOCKER)
            cell.value = category
    cell.border = thin_border

# Apply alignments and borders to data rows
for row in range(4, ws.max_row + 1):  # Start from row 4 (data rows)
    for col in range(1, ws.max_column + 1):
        cell = ws.cell(row=row, column=col)
        # Center-align all cells except the project column
        if col == 1:  # Project column
            cell.alignment = Alignment(horizontal="left", vertical="center")
        else:
            cell.alignment = Alignment(horizontal="center", vertical="center")
        # Apply thin border to all cells
        cell.border = thin_border
        # Bold the Total row
        if row == ws.max_row:  # Total row
            cell.font = Font(bold=True)

# Apply bold outline to each date section
for i, date in enumerate(dates):
    start_col = 2 + i * total_cols_per_date  # Start of the date section (e.g., B, M, X)
    end_col = start_col + total_cols_per_date - 1  # End of the date section (e.g., L, W, AH)
    for row in range(1, ws.max_row + 1):
        # Left border of the date section
        cell = ws.cell(row=row, column=start_col)
        cell.border = Border(
            left=Side(style="medium"),
            right=cell.border.right,
            top=cell.border.top,
            bottom=cell.border.bottom
        )
        # Right border of the date section (Total column)
        cell = ws.cell(row=row, column=end_col)
        cell.border = Border(
            left=cell.border.left,
            right=Side(style="medium"),
            top=cell.border.top,
            bottom=cell.border.bottom
        )
        # Top border of the date section (row 1)
        if row == 1:
            for col in range(start_col, end_col + 1):
                cell = ws.cell(row=row, column=col)
                cell.border = Border(
                    left=cell.border.left,
                    right=cell.border.right,
                    top=Side(style="medium"),
                    bottom=cell.border.bottom
                )
        # Bottom border of the date section (Total row)
        if row == ws.max_row:
            for col in range(start_col, end_col + 1):
                cell = ws.cell(row=row, column=col)
                cell.border = Border(
                    left=cell.border.left,
                    right=cell.border.right,
                    top=cell.border.top,
                    bottom=Side(style="medium")
                )

# Apply bold outline to the project column
for row in range(1, ws.max_row + 1):
    cell = ws.cell(row=row, column=1)
    # Left border
    cell.border = Border(
        left=Side(style="medium"),
        right=cell.border.right,
        top=cell.border.top,
        bottom=cell.border.bottom
    )
    # Top border
    if row == 1:
        cell.border = Border(
            left=cell.border.left,
            right=cell.border.right,
            top=Side(style="medium"),
            bottom=cell.border.bottom
        )
    # Bottom border
    if row == ws.max_row:
        cell.border = Border(
            left=cell.border.left,
            right=cell.border.right,
            top=cell.border.top,
            bottom=Side(style="medium")
        )

# Save the modified Excel file
wb.save("Final.xlsx")

print("Data downloaded, pivot table created, and formatting applied successfully!")