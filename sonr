import requests
import base64
import pandas as pd
from datetime import datetime, timedelta
from openpyxl import load_workbook, Workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment, Font, Border, Side, PatternFill
import os
import json  # Import the json module

class SonarQubeDataProcessor:
    def __init__(self, sonartoken):
        self.sonartoken = sonartoken
        self.auth_string = f"{sonartoken}:"
        self.auth_encoded = base64.b64encode(self.auth_string.encode()).decode()
        self.headers = {
            "Authorization": f"Basic {self.auth_encoded}",
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
        self.text = None  # Store raw response text if needed

    def fetch_projects(self):
        project_url = "https://sonar.crm.com/api/components/search?qualifiers=TRK&ps=500"
        response = requests.get(project_url, headers=self.headers)
        # Store the raw response text if needed
        self.text = response.text
        # Parse the JSON response
        projects_data = self.parse_json()
        if projects_data is None:
            raise ValueError("Failed to parse projects data")

        # Extract project details
        projects_list = []
        for component in projects_data.get("components", []):
            projects_list.append({
                "key": component["key"],
                "name": component["name"],
                "project": component["name"]
            })

        # Save to Projects.xlsx
        projects_df = pd.DataFrame(projects_list)
        projects_df.to_excel("Projects.xlsx", index=False)
        return projects_df

    def parse_json(self):
        """Parse the JSON string stored in self.text."""
        try:
            return json.loads(self.text)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON: {e}")
            return None
        except AttributeError as e:
            print(f"Attribute error: {e}")
            return None

    def fetch_vulnerabilities(self, projects_df):
        vulnerabilities_list = []
        for key in projects_df["key"]:
            page = 1
            while True:
                vuln_url = f"https://sonar.crm.com/api/issues/search?componentKeys={key}&types=VULNERABILITY&resolved=false&statuses=OPEN&p={page}"
                response = requests.get(vuln_url, headers=self.headers)
                vuln_data = response.json()  # Directly parse JSON

                # Extract issues from the current page
                issues = vuln_data.get("issues", [])
                for issue in issues:
                    vulnerabilities_list.append({
                        "key": issue["key"],
                        "severity": issue.get("severity", ""),
                        "component": issue.get("component", ""),
                        "project": issue.get("project", ""),
                        "line": issue.get("line", ""),
                        "status": issue.get("status", ""),
                        "message": issue.get("message", "")
                    })

                # Check pagination metadata
                total = vuln_data.get("total", 0)
                page_size = vuln_data.get("ps", 100)
                current_page = vuln_data.get("p", 1)

                if len(issues) < page_size or (current_page * page_size) >= total:
                    break

                page += 1

        # Save to Vulnerabilities.xlsx
        vulnerabilities_df = pd.DataFrame(vulnerabilities_list)
        vulnerabilities_df.to_excel("Vulnerabilities.xlsx", index=False)
        return vulnerabilities_df

    def fetch_hotspots(self, projects_df):
        hotspots_list = []
        for key in projects_df["key"]:
            page = 1
            while True:
                hotspot_url = f"https://sonar.crm.com/api/hotspots/search?projectKey={key}&status=TO_REVIEW&p={page}"
                response = requests.get(hotspot_url, headers=self.headers)
                hotspot_data = response.json()

                # Extract hotspots
                hotspots = hotspot_data.get("hotspots", [])
                for hotspot in hotspots:
                    hotspots_list.append({
                        "key": hotspot["key"],
                        "component": hotspot.get("component", ""),
                        "project": hotspot.get("project", ""),
                        "securityCategory": hotspot.get("securityCategory", ""),
                        "vulnerabilityProbability": hotspot.get("vulnerabilityProbability", ""),
                        "status": hotspot.get("status", ""),
                        "line": hotspot.get("line", ""),
                        "message": hotspot.get("message", "")
                    })

                # Check pagination metadata
                paging = hotspot_data.get("paging", {})
                total = paging.get("total", 0)
                page_size = paging.get("pageSize", 100)
                current_page = paging.get("pageIndex", 1)

                if len(hotspots) < page_size or (current_page * page_size) >= total:
                    break

                page += 1

        # Save to Hotspots.xlsx
        hotspots_df = pd.DataFrame(hotspots_list)
        hotspots_df.to_excel("Hotspots.xlsx", index=False)
        return hotspots_df

    def create_pivot_table(self, vulnerabilities_df, hotspots_df):
        # Get unique project keys
        unique_projects = set(vulnerabilities_df["project"]).union(set(hotspots_df["project"]))

        # Dynamically get the current date
        current_date = datetime.now()
        current_date_str = current_date.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")

        # Define categories
        vuln_categories = ["BLOCKER", "CRITICAL", "MAJOR", "MINOR", "INFO"]
        hotspot_categories = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "OTHER"]

        # Number of columns per date
        vuln_cols_per_date = len(vuln_categories)  # 5
        hotspot_cols_per_date = len(hotspot_categories)  # 5
        total_cols_per_date = vuln_cols_per_date + hotspot_cols_per_date + 1  # 11

        # Check if Final.xlsx exists
        if os.path.exists("Final.xlsx"):
            wb = load_workbook("Final.xlsx")
            ws = wb.active
            existing_dates = set()
            for col in range(2, ws.max_column + 1, total_cols_per_date):
                date_cell = ws.cell(row=1, column=col).value
                if date_cell:
                    try:
                        if isinstance(date_cell, datetime):
                            date_str = date_cell.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")
                        else:
                            date_str = str(date_cell).strip()
                            for fmt in ["%d-%b-%y", "%d-%b-%Y", "%d-%B-%Y", "%d-%b-%Y"]:
                                try:
                                    parsed_date = datetime.strptime(date_str, fmt)
                                    date_str = parsed_date.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")
                                    break
                                except ValueError:
                                    continue
                            else:
                                continue
                        existing_dates.add(date_str)
                    except Exception as e:
                        print(f"Error parsing date {date_cell}: {e}")
                        continue
            wb.close()

            dates = list(existing_dates) + [current_date_str]
        else:
            dates = [current_date_str]
            existing_projects = set()

        # Remove duplicates and sort dates
        dates = sorted(list(set(dates)))

        # Load existing projects
        if os.path.exists("Final.xlsx"):
            existing_df = pd.read_excel("Final.xlsx", header=2)
            existing_df.columns = ["project"] + list(existing_df.columns[1:])

            # Normalize column names in existing_df
            renamed_columns = ["project"]
            for col in existing_df.columns[1:]:
                parts = col.split("_")
                if len(parts) >= 3:
                    date_part = parts[0]
                    type_part = parts[1].upper()
                    category_part = parts[2].upper()
                    try:
                        parsed_date = datetime.strptime(date_part, "%d-%b-%y")
                        date_part = parsed_date.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")
                    except ValueError:
                        pass
                    renamed_columns.append(f"{date_part}_{type_part}_{category_part}")
                else:
                    if col.endswith("_Total"):
                        date_part = col.replace("_Total", "")
                        try:
                            parsed_date = datetime.strptime(date_part, "%d-%b-%y")
                            date_part = parsed_date.strftime("%d-%b-%y").replace("May", "May").replace("Jan", "Jan")
                        except ValueError:
                            pass
                        renamed_columns.append(f"{date_part}_Total")
                    else:
                        renamed_columns.append(col)
            existing_df.columns = renamed_columns

            existing_projects = set(existing_df["project"].values)
            if "Total" in existing_projects:
                existing_projects.remove("Total")
        else:
            existing_projects = set()

        # Initialize the pivot table structure (only for the current date)
        pivot_data = []
        all_projects = unique_projects.union(existing_projects)

        for project in all_projects:
            row = {"project": project}
            
            # Only calculate counts for the current date
            vuln_filtered = vulnerabilities_df[vulnerabilities_df["project"] == project]
            hotspot_filtered = hotspots_df[hotspots_df["project"] == project]

            for category in vuln_categories:
                count = len(vuln_filtered[vuln_filtered["severity"] == category])
                row[f"{current_date_str}_VULNERABILITY_{category}"] = count if count > 0 else None

            for category in hotspot_categories:
                count = len(hotspot_filtered[hotspot_filtered["vulnerabilityProbability"] == category])
                row[f"{current_date_str}_HOTSPOT_{category}"] = count if count > 0 else None

            total = 0
            for category in vuln_categories:
                count = row.get(f"{current_date_str}_VULNERABILITY_{category}", 0)
                total += count if count is not None else 0
            for category in hotspot_categories:
                count = row.get(f"{current_date_str}_HOTSPOT_{category}", 0)
                total += count if count is not None else 0
            row[f"{current_date_str}_Total"] = total if total > 0 else None

            pivot_data.append(row)

        # Create DataFrame for the pivot table
        pivot_df = pd.DataFrame(pivot_data)

        # Merge with existing data
        if os.path.exists("Final.xlsx"):
            existing_df = pd.read_excel("Final.xlsx", header=2)
            existing_df.columns = ["project"] + list(existing_df.columns[1:])
            existing_df = existing_df[existing_df["project"] != "Total"]
            combined_df = existing_df.set_index("project").combine_first(pivot_df.set_index("project")).reset_index()
            pivot_df = combined_df.copy()

        # Reorder columns
        columns_order = ["project"]
        for date in dates:
            columns_order.extend([f"{date}_VULNERABILITY_{category}" for category in vuln_categories])
            columns_order.extend([f"{date}_HOTSPOT_{category}" for category in hotspot_categories])
            columns_order.append(f"{date}_Total")
        pivot_df = pivot_df[columns_order]

        # Add Total row
        total_row = {"project": "Total"}
        for col in pivot_df.columns[1:]:
            total_row[col] = pivot_df[col].sum()
        total_df = pd.DataFrame([total_row])
        pivot_df = pd.concat([pivot_df, total_df], ignore_index=True)

        # Save to Final.xlsx
        with pd.ExcelWriter("Final.xlsx", engine="openpyxl") as writer:
            pivot_df.to_excel(writer, index=False, startrow=2)

        # Format the Excel file
        wb = load_workbook("Final.xlsx")
        ws = wb.active

        thin_border = Border(
            left=Side(style="thin"),
            right=Side(style="thin"),
            top=Side(style="thin"),
            bottom=Side(style="thin")
        )
        bold_border = Border(
            left=Side(style="medium"),
            right=Side(style="medium"),
            top=Side(style="medium"),
            bottom=Side(style="medium")
        )
        gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")

        for i, date in enumerate(dates):
            start_col = 2 + i * total_cols_per_date
            end_col = start_col + total_cols_per_date - 1
            start_col_letter = get_column_letter(start_col)
            end_col_letter = get_column_letter(end_col)
            ws.merge_cells(f"{start_col_letter}1:{end_col_letter}1")
            date_cell = ws[f"{start_col_letter}1"]
            date_cell.value = date
            date_cell.alignment = Alignment(horizontal="center", vertical="center")
            date_cell.font = Font(bold=True)
            date_cell.fill = gray_fill
            for col in range(start_col, end_col + 1):
                ws.cell(row=1, column=col).border = thin_border

        for i, date in enumerate(dates):
            vuln_start_col = 2 + i * total_cols_per_date
            vuln_end_col = vuln_start_col + vuln_cols_per_date - 1
            vuln_start_col_letter = get_column_letter(vuln_start_col)
            vuln_end_col_letter = get_column_letter(vuln_end_col)
            ws.merge_cells(f"{vuln_start_col_letter}2:{vuln_end_col_letter}2")
            vuln_cell = ws[f"{vuln_start_col_letter}2"]
            vuln_cell.value = "VULNERABILITY"
            vuln_cell.alignment = Alignment(horizontal="center", vertical="center")
            vuln_cell.font = Font(bold=True)
            for col in range(vuln_start_col, vuln_end_col + 1):
                ws.cell(row=2, column=col).border = thin_border

            hotspot_start_col = vuln_end_col + 1
            hotspot_end_col = hotspot_start_col + hotspot_cols_per_date - 1
            hotspot_start_col_letter = get_column_letter(hotspot_start_col)
            hotspot_end_col_letter = get_column_letter(hotspot_end_col)
            ws.merge_cells(f"{hotspot_start_col_letter}2:{hotspot_end_col_letter}2")
            hotspot_cell = ws[f"{hotspot_start_col_letter}2"]
            hotspot_cell.value = "HOTSPOT"
            hotspot_cell.alignment = Alignment(horizontal="center", vertical="center")
            hotspot_cell.font = Font(bold=True)
            for col in range(hotspot_start_col, hotspot_end_col + 1):
                ws.cell(row=2, column=col).border = thin_border

        for col_idx, col_name in enumerate(pivot_df.columns, start=1):
            cell = ws.cell(row=3, column=col_idx)
            if col_name != "project":
                if col_name.endswith("_Total"):
                    cell.value = "Total"
                else:
                    category = col_name.split("_")[-1]
                    cell.value = category
            cell.border = thin_border

        for row in range(4, ws.max_row + 1):
            for col in range(1, ws.max_column + 1):
                cell = ws.cell(row=row, column=col)
                if col == 1:
                    cell.alignment = Alignment(horizontal="left", vertical="center")
                else:
                    cell.alignment = Alignment(horizontal="center", vertical="center")
                cell.border = thin_border
                if row == ws.max_row:
                    cell.font = Font(bold=True)

        for i, date in enumerate(dates):
            start_col = 2 + i * total_cols_per_date
            end_col = start_col + total_cols_per_date - 1
            for row in range(1, ws.max_row + 1):
                cell = ws.cell(row=row, column=start_col)
                cell.border = Border(
                    left=Side(style="medium"),
                    right=cell.border.right,
                    top=cell.border.top,
                    bottom=cell.border.bottom
                )
                cell = ws.cell(row=row, column=end_col)
                cell.border = Border(
                    left=cell.border.left,
                    right=Side(style="medium"),
                    top=cell.border.top,
                    bottom=cell.border.bottom
                )
                if row == 1:
                    for col in range(start_col, end_col + 1):
                        cell = ws.cell(row=row, column=col)
                        cell.border = Border(
                            left=cell.border.left,
                            right=cell.border.right,
                            top=Side(style="medium"),
                            bottom=cell.border.bottom
                        )
                if row == ws.max_row:
                    for col in range(start_col, end_col + 1):
                        cell = ws.cell(row=row, column=col)
                        cell.border = Border(
                            left=cell.border.left,
                            right=cell.border.right,
                            top=cell.border.top,
                            bottom=Side(style="medium")
                        )

        for row in range(1, ws.max_row + 1):
            cell = ws.cell(row=row, column=1)
            cell.border = Border(
                left=Side(style="medium"),
                right=cell.border.right,
                top=cell.border.top,
                bottom=cell.border.bottom
            )
            if row == 1:
                cell.border = Border(
                    left=cell.border.left,
                    right=cell.border.right,
                    top=Side(style="medium"),
                    bottom=cell.border.bottom
                )
            if row == ws.max_row:
                cell.border = Border(
                    left=cell.border.left,
                    right=cell.border.right,
                    top=cell.border.top,
                    bottom=Side(style="medium")
                )

        wb.save("Final.xlsx")

        print("Data downloaded, pivot table created, and formatting applied successfully!")

# Run the script
if __name__ == "__main__":
    processor = SonarQubeDataProcessor(sonartoken="gdjdjdjdjdjrjjrjd")
    projects_df = processor.fetch_projects()
    vulnerabilities_df = processor.fetch_vulnerabilities(projects_df)
    hotspots_df = processor.fetch_hotspots(projects_df)
    processor.create_pivot_table(vulnerabilities_df, hotspots_df)