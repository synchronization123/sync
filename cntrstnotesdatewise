# Save this file as contrast_traces.py
import requests
import pandas as pd
from datetime import datetime, timedelta
import os
import tkinter as tk
from tkinter import ttk, messagebox
import threading
from concurrent.futures import ThreadPoolExecutor
from openpyxl import load_workbook
from openpyxl.styles import Border, Side, Alignment, Font
from tkcalendar import DateEntry  # Requires tkcalendar: pip install tkcalendar

# Set the working directory to the script's directory
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# GUI Class
class App:
    def __init__(self, root):
        self.root = root
        self.root.title("Contrast Traces Processor")
        self.root.geometry("600x500")

        # Frame for date inputs
        self.date_frame = ttk.Frame(self.root)
        self.date_frame.pack(pady=10)

        # Start date picker
        ttk.Label(self.date_frame, text="Start Date:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.start_date_entry = DateEntry(
            self.date_frame,
            width=12,
            background='darkblue',
            foreground='white',
            borderwidth=2,
            year=2025,
            month=1,
            day=1,
            date_pattern='yyyy-mm-dd'
        )
        self.start_date_entry.grid(row=0, column=1, padx=5, pady=5)

        # End date picker
        ttk.Label(self.date_frame, text="End Date:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.end_date_entry = DateEntry(
            self.date_frame,
            width=12,
            background='darkblue',
            foreground='white',
            borderwidth=2,
            year=datetime.now().year,
            month=datetime.now().month,
            day=datetime.now().day,
            date_pattern='yyyy-mm-dd'
        )
        self.end_date_entry.grid(row=1, column=1, padx=5, pady=5)

        # Frame for button, loading, and progress
        self.top_frame = ttk.Frame(self.root)
        self.top_frame.pack(pady=10)

        # Run button
        self.run_button = ttk.Button(self.top_frame, text="Run Script", command=self.start_script)
        self.run_button.pack(side=tk.LEFT, padx=5)

        # Loading label
        self.loading_label = ttk.Label(self.top_frame, text="")
        self.loading_label.pack(side=tk.LEFT, padx=10)

        # Progress bar
        self.progress = ttk.Progressbar(self.top_frame, length=300, mode='determinate')
        self.progress.pack(side=tk.LEFT, padx=5)

        # Text area for console logs
        self.log_frame = ttk.Frame(self.root)
        self.log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.log_text = tk.Text(self.log_frame, height=15, width=70, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)

        # Scrollbar for log text
        scrollbar = ttk.Scrollbar(self.log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text['yscrollcommand'] = scrollbar.set

    def log(self, message):
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, f"{datetime.now().strftime('%H:%M:%S')}: {message}\n")
        self.log_text.configure(state='disabled')
        self.log_text.see(tk.END)

    def validate_dates(self):
        try:
            start_date = self.start_date_entry.get_date()
            end_date = self.end_date_entry.get_date()
            # Convert to datetime and set time to midnight
            start_date = datetime.combine(start_date, datetime.min.time())
            end_date = datetime.combine(end_date, datetime.max.time())
            if start_date > end_date:
                raise ValueError("Start date cannot be after end date.")
            return start_date, end_date
        except ValueError as e:
            self.log(f"Date validation error: {e}")
            messagebox.showerror("Error", f"Invalid date selection: {e}")
            return None, None

    def start_script(self):
        start_date, end_date = self.validate_dates()
        if start_date is None or end_date is None:
            self.run_button.config(state='normal')
            return

        self.run_button.config(state='disabled')
        self.loading_label.config(text="Loading")
        self.animate_loading()
        threading.Thread(target=self.run_script_thread, args=(start_date, end_date), daemon=True).start()

    def animate_loading(self):
        def update_dots():
            if self.loading_label.cget("text").startswith("Loading"):
                dots = self.loading_label.cget("text")[7:]
                if dots == "...":
                    self.loading_label.config(text="Loading")
                else:
                    self.loading_label.config(text="Loading" + dots + ".")
                self.root.after(1000, update_dots)
        self.root.after(1000, update_dots)

    def run_script_thread(self, start_date, end_date):
        self.progress['value'] = 0
        self.log("Starting script execution...")

        # Convert dates to epoch milliseconds
        start_epoch = int(start_date.timestamp() * 1000)
        end_epoch = int(end_date.timestamp() * 1000)
        self.log(f"Filtering notes between {start_date.strftime('%Y-%m-%d')} and {end_date.strftime('%Y-%m-%d')} (Epoch: {start_epoch} to {end_epoch})")

        # Step 1: Fetch applications (33% progress)
        self.log("Fetching applications data...")
        self.progress['value'] = 10
        applications = self.fetch_applications()
        self.progress['value'] = 33

        # Step 2: Fetch traces (33% progress)
        self.log("Fetching traces data...")
        traces = self.fetch_traces(applications)
        self.progress['value'] = 66

        # Step 3: Fetch notes and generate Final.xlsx (34% progress)
        self.log("Fetching notes and generating Final.xlsx...")
        self.generate_final_xlsx(traces, start_epoch, end_epoch)
        self.progress['value'] = 100

        # Finalize
        self.loading_label.config(text="")
        self.run_button.config(state='normal')
        self.log("Script execution completed.")
        self.root.after(0, lambda: messagebox.showinfo("Success", "Final Excel data is ready in Final.xlsx"))

    def fetch_applications(self):
        contrast_token = 'dhdjdjdjdjrjrjrjdj=='  # Replace with actual token
        org_uuid = 'gshdhdhd'  # Replace with actual Org UUID
        api_key = 'hhjkkjdddjdkdk'  # Replace with actual API key

        headers = {
            'Authorization': contrast_token,
            'Api-key': api_key,
            'Accept': 'application/json'
        }

        base_url = 'https://crm.contrast.com/api/ng/'
        url = f"{base_url}{org_uuid}/applications/filter"
        applications = []

        with requests.Session() as session:
            session.headers.update(headers)
            try:
                response = session.get(url, timeout=10)
                if response.status_code == 200:
                    data = response.json()
                    for app in data.get('applications', []):
                        applications.append({
                            'name': app.get('name', ''),
                            'app_id': app.get('app_id', '')
                        })
                    # Save to applications.xlsx
                    df = pd.DataFrame(applications)
                    df.to_excel(os.path.join(script_dir, 'applications.xlsx'), index=False)
                    self.log("Applications saved to applications.xlsx")
                else:
                    self.log(f"Error fetching applications: {response.status_code} - {response.text}")
            except Exception as e:
                self.log(f"Exception fetching applications: {e}")
        
        return applications

    def fetch_traces(self, applications):
        contrast_token = 'dhdjdjdjdjrjrjrjdj=='  # Replace with actual token
        org_uuid = 'gshdhdhd'  # Replace with actual Org UUID
        api_key = 'hhjkkjdddjdkdk'  # Replace with actual API key

        headers = {
            'Authorization': contrast_token,
            'Api-key': api_key,
            'Accept': 'application/json'
        }

        base_url = 'https://crm.contrast.com/api/ng/'
        traces = []
        statuses = ['Confirmed', 'Not a Problem', 'Remediated', 'Fixed', 'Suspicious']

        def fetch_traces_for_app(app):
            app_id = app['app_id']
            app_traces = []
            for status in statuses:
                # Limit to last 1000 traces per status
                url = f"{base_url}{org_uuid}/traces/{app_id}/filter?limit=1000&status={status}&sort=-last_time_seen"
                try:
                    response = session.get(url, timeout=10)
                    if response.status_code == 200:
                        data = response.json()
                        traces_fetched = data.get('traces', [])
                        self.log(f"Fetched {len(traces_fetched)} traces for App ID {app_id}, Status {status}")
                        for trace in traces_fetched[:1000]:  # Ensure no more than 1000 traces
                            app_traces.append({
                                'name': app['name'],
                                'app_id': app_id,
                                'severity': trace.get('severity', ''),
                                'uuid': trace.get('uuid', ''),
                                'rule_name': trace.get('rule_name', ''),
                                'rule_title': trace.get('rule_title', ''),
                                'status': trace.get('status', '')
                            })
                    else:
                        self.log(f"Error for App ID {app_id}, Status {status}: {response.status_code} - {response.text}")
                except Exception as e:
                    self.log(f"Exception for App ID {app_id}, Status {status}: {e}")
            return app_traces

        with requests.Session() as session:
            session.headers.update(headers)
            with ThreadPoolExecutor(max_workers=5) as executor:
                results = list(executor.map(fetch_traces_for_app, applications))

        for result in results:
            traces.extend(result)

        # Save to Traces.xlsx
        df = pd.DataFrame(traces)
        df.to_excel(os.path.join(script_dir, 'Traces.xlsx'), index=False)
        self.log(f"Traces saved to Traces.xlsx (Total: {len(traces)})")
        return traces

    def generate_final_xlsx(self, traces, start_epoch, end_epoch):
        contrast_token = 'dhdjdjdjdjrjrjrjdj=='  # Replace with actual token
        org_uuid = 'gshdhdhd'  # Replace with actual Org UUID
        api_key = 'hhjkkjdddjdkdk'  # Replace with actual API key

        headers = {
            'Authorization': contrast_token,
            'Api-key': api_key,
            'Accept': 'application/json'
        }

        base_url = 'https://crm.contrast.com/api/ng/'
        final_data = []
        max_notes = 0  # Track the maximum number of notes for any trace

        def fetch_notes(trace):
            nonlocal max_notes
            app_id = trace['app_id']
            trace_uuid = trace['uuid']
            url = f"{base_url}{org_uuid}/applications/{app_id}/traces/{trace_uuid}/notes"
            try:
                response = session.get(url, timeout=10)
                if response.status_code == 200:
                    data = response.json()
                    notes = data.get('notes', [])
                    # Filter notes by creation date (epoch milliseconds)
                    filtered_notes = [
                        note for note in notes
                        if start_epoch <= note.get('creation', 0) <= end_epoch
                    ]
                    if filtered_notes:  # Only process traces with notes in date range
                        trace_data = {
                            'name': trace['name'],
                            'app_id': trace['app_id'],
                            'severity': trace['severity'],
                            'uuid': trace['uuid'],
                            'rule_name': trace['rule_name'],
                            'rule_title': trace['rule_title'],
                            'current_status': trace['status']
                        }
                        # Process notes and extract previous status and creator
                        for i, note in enumerate(filtered_notes, 1):
                            trace_data[f'note_{i}'] = note.get('note', '')
                            trace_data[f'current_creator_{i}'] = note.get('creator', '')
                            trace_data[f'creator_uid_{i}'] = note.get('creator_uid', '')
                            creation_time = note.get('creation', 0) / 1000  # Convert to seconds
                            trace_data[f'creation_{i}'] = datetime.fromtimestamp(creation_time).strftime('%Y-%m-%d %H:%M:%S')
                            # Extract previous status and creator from Properties
                            properties = note.get('properties', [])
                            previous_status = ''
                            previous_creator = ''
                            for prop in properties:
                                if prop.get('name') == 'status.change.previous.status':
                                    previous_status = prop.get('value', '')
                                if prop.get('name') == 'status.changed.creator':
                                    previous_creator = prop.get('value', '')
                            trace_data[f'previous_status_{i}'] = previous_status
                            trace_data[f'previous_creator_{i}'] = previous_creator
                        max_notes = max(max_notes, len(filtered_notes))
                        final_data.append(trace_data)
                else:
                    self.log(f"Error for Trace {trace_uuid}: {response.status_code} - {response.text}")
            except Exception as e:
                self.log(f"Exception for Trace {trace_uuid}: {e}")

        with requests.Session() as session:
            session.headers.update(headers)
            with ThreadPoolExecutor(max_workers=5) as executor:
                executor.map(fetch_notes, traces)

        if not final_data:
            self.log("No traces with notes found in the specified date range.")
            return

        # Create DataFrame with dynamic columns based on max_notes
        columns = ['name', 'app_id', 'severity', 'uuid', 'rule_name', 'rule_title', 'current_status']
        for i in range(1, max_notes + 1):
            columns.extend([f'previous_status_{i}', f'previous_creator_{i}'])
        for i in range(1, max_notes + 1):
            columns.extend([f'note_{i}', f'current_creator_{i}', f'creator_uid_{i}', f'creation_{i}'])
        
        # Convert final_data to DataFrame, ensuring all columns are present
        df = pd.DataFrame(final_data)
        for col in columns:
            if col not in df.columns:
                df[col] = ''
        df = df[columns]  # Reorder columns

        # Save to Final.xlsx
        excel_file = os.path.join(script_dir, 'Final.xlsx')
        df.to_excel(excel_file, index=False)
        self.log("Final data saved to Final.xlsx")

        # Apply formatting
        wb = load_workbook(excel_file)
        ws = wb.active

        # Define borders
        medium_border = Border(
            left=Side(style='medium'), right=Side(style='medium'),
            top=Side(style='medium'), bottom=Side(style='medium')
        )
        thin_border = Border(
            left=Side(style='thin'), right=Side(style='thin'),
            top=Side(style='thin'), bottom=Side(style='thin')
        )
        center_align = Alignment(horizontal='center', vertical='center')
        left_align = Alignment(horizontal='left', vertical='center')
        bold_font = Font(bold=True)

        # Apply formatting to headers
        for col_idx in range(1, ws.max_column + 1):
            cell = ws.cell(row=1, column=col_idx)
            cell.font = bold_font
            cell.alignment = center_align if col_idx > 1 else left_align
            cell.border = thin_border

        # Apply formatting to data rows
        for row_idx in range(2, ws.max_row + 1):
            for col_idx in range(1, ws.max_column + 1):
                cell = ws.cell(row=row_idx, column=col_idx)
                cell.alignment = center_align if col_idx > 1 else left_align
                # Apply medium borders to previous status/creator groups (2 columns)
                if col_idx > 7 and col_idx <= (7 + max_notes * 2) and (col_idx - 8) % 2 == 0:
                    cell.border = medium_border
                # Apply medium borders to note groups (4 columns)
                elif col_idx > (7 + max_notes * 2) and (col_idx - 8 - max_notes * 2) % 4 == 0:
                    cell.border = medium_border
                elif col_idx > (7 + max_notes * 2) and (col_idx - 9 - max_notes * 2) % 4 == 0:
                    cell.border = medium_border
                elif col_idx > (7 + max_notes * 2) and (col_idx - 10 - max_notes * 2) % 4 == 0:
                    cell.border = medium_border
                elif col_idx > (7 + max_notes * 2) and (col_idx - 11 - max_notes * 2) % 4 == 0:
                    cell.border = medium_border
                else:
                    cell.border = thin_border

        wb.save(excel_file)
        self.log("Formatting applied to Final.xlsx")

if __name__ == "__main__":
    root = tk.Tk()
    app = App(root)
    root.mainloop()